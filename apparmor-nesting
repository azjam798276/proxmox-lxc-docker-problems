AppArmor Nesting: A Case Study in Proxmox+LXC Virtualization Conflicts
(Analysis Date: October 4, 2025)

1. Executive Summary
This report documents the forensic investigation into a persistent and critical failure of the docker build process within a modern, privileged Proxmox LXC container. The initial symptom—a simple build failure—masked a complex, multi-layered architectural conflict between the Proxmox host, the LXC container's virtualized kernel interface, and the Docker daemon's security model.

Initial troubleshooting focused on application-level issues (the vLLM Dockerfile) and progressed through environmental misconfigurations (AppArmor, cgroup drivers). Each attempted fix, while logical, failed to resolve the core issue, proving that the problem was not a simple bug but a fundamental conflict in how the Linux kernel's security features operate in a nested environment.

The final root cause was identified as a conflict between Docker's attempt to escalate privileges to create a nested AppArmor security namespace and the Proxmox host kernel's refusal to allow this operation, even within a privileged and "unconfined" container. The definitive solution was to reconfigure the Docker daemon itself to prevent this privilege escalation, thereby resolving the conflict at its source. This document serves as a methodical guide to diagnosing and resolving such deep-seated environmental conflicts.

2. Layer 1: The Initial Investigation - The "Application" Problem
The investigation began with the assumption that the problem was at the application layer.

Symptom: docker build failed at the first RUN instruction when building a specific version of the vLLM project.

Initial Hypothesis: The vLLM Dockerfile, its source code at the target tag (v0.11.0), or its dependencies were broken.

Actions Taken:

A forensic analysis of the vllm-project/vllm Git repository was conducted.

It was discovered that the simple v0.11.0 tag was a dead end and that the correct source code resided on a release-specific branch, releases/v0.11.0.

Outdated dependencies (like PyTorch versions) were identified and updated.

Outcome: The failure persisted with an identical error message. This proved the problem was not with the application code itself but with the environment it was being built in.

3. Layer 2: The Environmental Conflict - The "AppArmor" Problem
The error message provided the next clue, pointing toward the host's security system.

Symptom: runc run failed: unable to apply apparmor profile: ... no such file or directory.

Hypothesis: The AppArmor service on the Ubuntu LXC container was missing, disabled, or misconfigured.

Actions Taken:

The AppArmor service was reinstalled and verified to be active within the LXC container.

Multiple attempts were made to reconfigure the Docker daemon via /etc/docker/daemon.json with directives like "apparmor-profile": "unconfined", which failed because the daemon version did not support the key.

A manual workaround using docker run --security-opt apparmor=unconfined ... followed by docker commit was developed. This workaround succeeded, proving the issue was an environmental security conflict that could be bypassed with a direct override.

Outcome: While a manual solution was found, the root cause of the automated build failure was still unknown. The focus shifted from the container's configuration to the host's interaction with the container.

4. Layer 3: The Host-Guest Interaction - The "Proxmox LXC" Problem
This phase focused on the complete system profile to understand the deep interaction between the host and the container.

Symptom: The AppArmor error persisted in automated builds despite a modern host kernel (6.8.x) and a correctly configured LXC (lxc.apparmor.profile: unconfined).

Hypothesis: The conflict lies in the specific way Proxmox virtualizes the kernel and its security interfaces for the LXC container.

Actions Taken:

Full system specifications were gathered from both the Proxmox host and the LXC container, including pveversion, aa-status from both environments, lsb_release, docker info, and the LXC's .conf file.

The data confirmed all components were modern and configured according to best practices.

A final host-level fix was attempted by adding lxc.apparmor.allow_incomplete = 1 to the LXC configuration, which also failed to resolve the issue.

Outcome: All host-side and container-side configurations were ruled out. The problem had to be in the interaction between the Docker daemon and the virtualized kernel itself.

5. Layer 4: The Architectural Root Cause & Definitive Solution
The complete system profile, combined with the history of failed attempts, allowed for the final diagnosis.

Final Hypothesis (Synthesized from all data): The true conflict is a mismatch in how system resources are managed (cgroupfs vs. systemd) compounded by a fundamental Linux kernel limitation on nested AppArmor namespacing. The Docker daemon, even when running with systemd cgroups, still attempts to perform a privilege escalation to create a new security context for the build container. The Proxmox host kernel, by design, denies this nested operation, causing the build to fail.

The Definitive Solution: The final, successful solution was to reconfigure the Docker daemon to prevent this disallowed behavior.

Align Cgroup Drivers: The /etc/docker/daemon.json file in the LXC was configured to use the systemd cgroup driver, aligning it with the host OS.

Disable Privilege Escalation: Critically, the "no-new-privileges": true flag was added to the daemon.json. This instructs the kernel to forbid the Docker daemon's build processes from gaining any additional privileges, which fundamentally prevents the failing nested AppArmor operation from ever being attempted.

Final /etc/docker/daemon.json configuration:

{
  "exec-opts": ["native.cgroupdriver=systemd"],
  "no-new-privileges": true
}

6. Conclusion & Strategic Takeaways
The persistent docker build failure was not a bug but a deep architectural conflict inherent to running a modern Docker daemon inside a modern, security-hardened nested virtualization environment like Proxmox. The symptoms (AppArmor errors) were misleading; the root cause was Docker's attempt to perform a privileged operation that the host kernel, by design, denies to its guests.

The key takeaway is that for complex, nested environments, one must configure the guest services (like Docker) to be compliant with the host's security model. The final solution of aligning the cgroup driver and disabling new privileges is a robust framework for ensuring stability and resolving such conflicts.
