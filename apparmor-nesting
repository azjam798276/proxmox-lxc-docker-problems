AppArmor Nesting: A Case Study in Proxmox+LXC Virtualization Conflicts
(Analysis Date: October 4, 2025)

1. Executive Summary
This report documents the forensic investigation into a persistent and critical failure of the docker build process within a modern, privileged Proxmox LXC container. The initial symptom—a simple build failure—masked a complex, multi-layered architectural conflict. The investigation systematically peeled back layers of the system stack, moving from application-level code to guest OS configuration, and finally to the Proxmox host's core security policies.

While initial theories pointed to misconfigurations within the container (AppArmor, Docker daemon settings), all attempts to fix the issue at the guest level failed. The final, definitive root cause was discovered to be a deliberate security hardening measure on the Proxmox host itself: by default, Proxmox drops critical Linux Kernel Capabilities (CAP_MAC_ADMIN, CAP_MAC_OVERRIDE) from all LXC containers. This prevents any process inside the container, including Docker's runtime, from administering the AppArmor security module, leading to the build failure.

The definitive solution was a surgical modification of the host's global LXC configuration to grant these specific capabilities back to the container, resolving the conflict at its true source. This document serves as a methodical guide to diagnosing such deep-seated environmental conflicts, demonstrating that sometimes the solution lies not within the guest, but on the host that governs it.

2. Layer 1: The "Application" Problem
The investigation began with the assumption that the problem was at the application layer.

Symptom: docker build failed at the first RUN instruction when building a specific version of the vLLM project.

Initial Hypothesis: The vLLM Dockerfile, its source code at the target tag (v0.11.0), or its dependencies were broken.

Outcome: After extensive analysis of the vLLM Git repository, the correct source branch (releases/v0.11.0) and dependencies were identified. The failure persisted, proving the problem was not with the application code but with the environment it was being built in.

3. Layer 2: The "Guest OS" Problem
The error message pointed toward the guest operating system's security configuration.

Symptom: runc run failed: unable to apply apparmor profile: ... no such file or directory.

Hypothesis: The AppArmor service or the Docker daemon inside the Ubuntu LXC container was misconfigured.

Actions Taken:

AppArmor was reinstalled and verified as active.

The Docker daemon's cgroup driver was correctly aligned with the host's (systemd).

Multiple daemon configurations ("apparmor-profile": "unconfined", "no-new-privileges": true) were attempted. All failed, proving the container itself was not the source of the misconfiguration.

Outcome: The development of a manual workaround (docker run --security-opt apparmor=unconfined ... followed by docker commit) proved that the environmental conflict could be bypassed with a direct security override, shifting the focus to the host.

4. Layer 3: The "Host-Guest Interaction" Problem
This phase focused on the interaction between the Proxmox host and the LXC container.

Symptom: The error persisted despite a modern host kernel (6.8.x) and a correctly configured LXC (lxc.apparmor.profile: unconfined).

Hypothesis: The conflict lies in a subtle, undocumented aspect of how Proxmox virtualizes the kernel's security interfaces for the container.

Actions Taken:

Full system specifications were gathered from both the host and guest.

Advanced host-level fixes were attempted, including reinstalling AppArmor on the host and setting lxc.apparmor.allow_incomplete = 1.

Outcome: All configurations at both the host and guest level failed to resolve the issue, pointing to a non-obvious, default security policy rather than a bug or misconfiguration.

5. Layer 4: The Architectural Root Cause & Definitive Solution
The complete system profile, combined with the history of failed attempts, allowed for the final diagnosis.

Final Hypothesis (The Ground Truth): The true conflict originates from the Proxmox host's default LXC hardening policy. The global configuration file at /usr/share/lxc/config/common.conf contains a directive, lxc.cap.drop, which, for security reasons, removes a list of powerful Linux Kernel Capabilities from all containers by default.

Critically, this list includes:

mac_admin (CAP_MAC_ADMIN): The authority to administer the system's Mandatory Access Control (MAC) security—which includes AppArmor.

mac_override (CAP_MAC_OVERRIDE): The authority to override AppArmor restrictions.

The Docker build process fails because its runtime (runc) is denied the fundamental kernel-level authority to perform the AppArmor operations required to create a nested security context. It lacks the necessary capabilities because the Proxmox host explicitly took them away.

The Definitive Solution: The final, successful solution was a surgical modification of this default host policy to grant the necessary capabilities back to the containers.

Action: The following command was run on the Proxmox host:

sudo sed -i 's|mac_admin\ mac_override\ sys_time\ sys_module\ sys_rawio|sys_time\ sys_module\ sys_rawio|g' /usr/share/lxc/config/common.conf

This command edits the global LXC template, removing mac_admin and mac_override from the list of dropped capabilities. This grants all containers the precise authority needed for nested Docker builds to function correctly.

6. Conclusion & Strategic Takeaways
The persistent docker build failure was not a bug but a feature—a deliberate security hardening measure on the Proxmox host that had unintended consequences for a nested Docker-in-LXC workload. The symptoms (AppArmor errors in the guest) were layers removed from the true root cause (dropped kernel capabilities on the host).

The key takeaway is that for complex, nested virtualization environments, the host's default security posture is paramount. Troubleshooting must extend beyond the guest's configuration to the fundamental permissions and capabilities granted by the hypervisor itself. The final solution demonstrates that sometimes the fix is not to reconfigure the application or the guest, but to precisely adjust the foundational rules of the host environment that governs them.
